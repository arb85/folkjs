<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ZUI Simplified</title>
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        overflow: hidden;
        background: #f9f9f9;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      }

      #info-container {
        position: absolute;
        top: 10px;
        left: 10px;
        background-color: white;
        padding: 8px 10px;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        z-index: 2000;
        max-width: 300px;
        font-size: 12px;
        line-height: 1.4;

        & > div:first-child {
          font-weight: bold;
        }
      }

      button {
        padding: 5px 10px;
        cursor: pointer;
      }

      canvas {
        position: absolute;
        top: 0;
        left: 0;
      }
    </style>
  </head>
  <body>
    <div id="info-container">
      <div>Infinite ZUI</div>
      <div> Zoom in/out forever using a <em>floating origin graph.</em> </div>
      <div>Hold <kbd>shift</kbd> to zoom in, <kbd>alt+shift</kbd> to zoom out.</div>
      <div id="reference-node-info">reference frame: node1</div>
    </div>

    <canvas id="zui-canvas"></canvas>

    <script>
      // Define our node structure
      const nodes = {
        node1: {
          id: 'node1',
          prev: 'node8',
          next: 'node2',
          data: 'red',
          width: 150,
          height: 100,
          transform: new DOMMatrix().scale(0.5),
        },
        node2: {
          id: 'node2',
          prev: 'node1',
          next: 'node3',
          data: 'blue',
          width: 150,
          height: 100,
          transform: new DOMMatrix().scale(0.5).rotate(10),
        },
        node3: {
          id: 'node3',
          prev: 'node2',
          next: 'node4',
          data: 'green',
          width: 150,
          height: 100,
          transform: new DOMMatrix().scale(0.6),
        },
        node4: {
          id: 'node4',
          prev: 'node3',
          next: 'node5',
          data: 'grey',
          width: 150,
          height: 100,
          transform: new DOMMatrix().scale(0.6),
        },
        node5: {
          id: 'node5',
          prev: 'node4',
          next: 'node6',
          data: 'purple',
          width: 150,
          height: 100,
          transform: new DOMMatrix().scale(0.7),
        },
        node6: {
          id: 'node6',
          prev: 'node5',
          next: 'node7',
          data: 'orange',
          width: 180,
          height: 90,
          transform: new DOMMatrix().scale(0.65),
        },
        node7: {
          id: 'node7',
          prev: 'node6',
          next: 'node8',
          data: 'teal',
          width: 150,
          height: 100,
          transform: new DOMMatrix().scale(0.4),
        },
        node8: {
          id: 'node8',
          prev: 'node7',
          next: 'node1',
          data: 'magenta',
          width: 150,
          height: 100,
          transform: new DOMMatrix().scale(0.5),
        },
      };

      const VISIBLE_DISTANCE = 12;

      // Reference node ID
      let referenceNodeId = 'node1';

      // Viewport transform (reference node to viewport)
      let viewportTransform = new DOMMatrix().translate(0, 0).scale(1);

      // Setup canvas
      const canvas = document.getElementById('zui-canvas');
      const ctx = canvas.getContext('2d');

      // Resize canvas to window size
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        draw();
      }

      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();

      // Helper function to invert a transform
      function invertTransform(transform) {
        return transform.inverse();
      }

      // Function to get next nodes up to a specified distance
      function getNextNodes(startNodeId, distance) {
        const nextNodes = [startNodeId];

        let currentNodeId = startNodeId;
        let count = 0;
        while (nodes[currentNodeId].next && count < distance) {
          nextNodes.push(nodes[currentNodeId].next);
          currentNodeId = nodes[currentNodeId].next;
          count++;
        }

        return nextNodes;
      }

      // Draw function
      function draw() {
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Get visible nodes
        const visibleNodes = getNextNodes(referenceNodeId, VISIBLE_DISTANCE);

        // Save current state
        ctx.save();

        // Center the viewport
        ctx.translate(canvas.width / 2, canvas.height / 2);

        // Apply viewport transform
        ctx.transform(
          viewportTransform.a,
          viewportTransform.b,
          viewportTransform.c,
          viewportTransform.d,
          viewportTransform.e,
          viewportTransform.f,
        );

        // Draw the reference node first (at the origin)
        drawNode(referenceNodeId);

        // Draw next nodes with accumulated transforms
        let currentTransform = new DOMMatrix();

        for (let i = 1; i < visibleNodes.length; i++) {
          const nodeId = visibleNodes[i];
          const node = nodes[nodeId];

          ctx.save();

          // Accumulate transform for this node
          currentTransform = node.transform.multiply(currentTransform);

          // Apply the accumulated transform
          ctx.transform(
            currentTransform.a,
            currentTransform.b,
            currentTransform.c,
            currentTransform.d,
            currentTransform.e,
            currentTransform.f,
          );

          drawNode(nodeId);
          ctx.restore();
        }

        // Restore state
        ctx.restore();
      }

      // Function to draw a single node
      function drawNode(nodeId) {
        if (!nodeId) return;

        const node = nodes[nodeId];
        if (!node) return;

        // Use node's width and height
        const width = node.width || 100;
        const height = node.height || 100;

        // Draw a rectangle with the node's dimensions
        ctx.fillStyle = node.data;
        ctx.fillRect(-width / 2, -height / 2, width, height);

        // Add a border
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        ctx.strokeRect(-width / 2, -height / 2, width, height);

        // Add node ID text
        ctx.fillStyle = 'white';
        ctx.font = '20px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(node.id, 0, 0);
      }

      // Pan handling
      let isDragging = false;
      let lastX = 0;
      let lastY = 0;

      canvas.addEventListener('mousedown', (e) => {
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
      });

      // Add mouse position tracking
      let currentMouseX = canvas.width / 2;
      let currentMouseY = canvas.height / 2;

      // Update mouse position when it moves
      canvas.addEventListener('mousemove', (e) => {
        currentMouseX = e.clientX;
        currentMouseY = e.clientY;

        if (isDragging) {
          const dx = e.clientX - lastX;
          const dy = e.clientY - lastY;

          // Update viewport transform for panning
          viewportTransform = new DOMMatrix().translate(dx, dy).multiply(viewportTransform);

          lastX = e.clientX;
          lastY = e.clientY;

          draw();
        }
      });

      window.addEventListener('mouseup', () => {
        isDragging = false;
      });

      // Zoom with mouse wheel
      canvas.addEventListener('wheel', (e) => {
        e.preventDefault();

        // Calculate zoom factor (slower zoom speed)
        const zoomFactor = e.deltaY > 0 ? 0.95 : 1.05;

        // Get mouse position relative to canvas center
        const mouseX = e.clientX - canvas.width / 2;
        const mouseY = e.clientY - canvas.height / 2;

        // Update viewport transform for zooming
        // First translate to mouse position, then scale, then translate back
        viewportTransform = new DOMMatrix()
          .translate(mouseX, mouseY)
          .scale(zoomFactor)
          .translate(-mouseX, -mouseY)
          .multiply(viewportTransform);

        // Check if we need to change reference node based on zoom level
        if (e.deltaY > 0) {
          // Zooming out - check if we need to go to previous node
          checkForZoomOut();
        } else {
          // Zooming in - check if next node fills the screen
          checkForZoomIn();
        }

        draw();
      });

      // Function to check if the next node covers the screen (for zooming in)
      function checkForZoomIn() {
        const nextNodeId = nodes[referenceNodeId].next;
        if (!nextNodeId) return;

        const nextNode = nodes[nextNodeId];
        if (!nextNode) return;

        // Get the transform from reference node to next node
        const nextNodeTransform = getAccumulatedTransform(referenceNodeId, nextNodeId);

        // Calculate effective scale from combined viewport and node transform
        const combinedTransform = viewportTransform.multiply(nextNodeTransform);
        const effectiveScale = Math.hypot(combinedTransform.a, combinedTransform.b);

        // Calculate next node dimensions after transform
        const transformedWidth = nextNode.width * effectiveScale;
        const transformedHeight = nextNode.height * effectiveScale;

        // Check if next node covers the screen (with some buffer)
        if (transformedWidth > canvas.width * 1.2 && transformedHeight > canvas.height * 1.2) {
          // Move to next node
          changeReferenceNodeForward();
        }
      }

      // Function to check if the current node is too small (for zooming out)
      function checkForZoomOut() {
        const node = nodes[referenceNodeId];
        if (!node) return;

        // Get the previous node ID
        const prevNodeId = node.prev;
        if (!prevNodeId) return;

        // Calculate effective scale from viewport transform
        const effectiveScale = Math.hypot(viewportTransform.a, viewportTransform.b);

        // Calculate current node dimensions after transform
        const transformedWidth = node.width * effectiveScale;
        const transformedHeight = node.height * effectiveScale;

        // Check if current node is too small on screen (with buffer)
        if (transformedWidth < canvas.width || transformedHeight < canvas.height) {
          // Move to previous node
          changeReferenceNodeBackward();
        }
      }

      // Remove the shift-click event and add continuous zooming functionality
      let isShiftZooming = false;
      let isAltShiftZooming = false;
      let zoomInterval = null;

      // Add keyboard event listeners for continuous zooming
      window.addEventListener('keydown', (e) => {
        if (e.shiftKey && !e.altKey && !isShiftZooming) {
          isShiftZooming = true;
          startContinuousZoom(true);
        } else if (e.shiftKey && e.altKey && !isAltShiftZooming) {
          isAltShiftZooming = true;
          startContinuousZoom(false);
        }
      });

      window.addEventListener('keyup', (e) => {
        if (!e.shiftKey || (isAltShiftZooming && !e.altKey)) {
          isShiftZooming = false;
          isAltShiftZooming = false;
          stopContinuousZoom();
        }
      });

      function startContinuousZoom(zoomIn) {
        stopContinuousZoom(); // Clear any existing interval

        const zoomFactor = zoomIn ? 1.02 : 0.98;

        zoomInterval = setInterval(() => {
          // Get mouse position relative to canvas center
          const mouseX = currentMouseX - canvas.width / 2;
          const mouseY = currentMouseY - canvas.height / 2;

          // Apply zoom transform centered on mouse position
          viewportTransform = new DOMMatrix()
            .translate(mouseX, mouseY)
            .scale(zoomFactor)
            .translate(-mouseX, -mouseY)
            .multiply(viewportTransform);

          // Check if we need to change reference node
          if (zoomIn) {
            checkForZoomIn();
          } else {
            checkForZoomOut();
          }

          draw();
        }, 16); // ~60fps
      }

      function stopContinuousZoom() {
        if (zoomInterval) {
          clearInterval(zoomInterval);
          zoomInterval = null;
        }
      }

      // Helper function to get the current screen position of a node
      function getNodeScreenPosition(nodeId) {
        let transform = new DOMMatrix();

        // Accumulate transforms from reference node to target node
        let currentNodeId = referenceNodeId;
        while (currentNodeId !== nodeId) {
          currentNodeId = nodes[currentNodeId].next;
          if (!currentNodeId) break;
          transform = nodes[currentNodeId].transform.multiply(transform);
        }

        // Apply viewport transform
        transform = viewportTransform.multiply(transform);

        // The node is drawn at the canvas center, so apply canvas center offset
        const screenX = canvas.width / 2 + transform.e;
        const screenY = canvas.height / 2 + transform.f;

        return { x: screenX, y: screenY };
      }

      // Helper function to get the accumulated transform from reference node to target node
      function getAccumulatedTransform(fromNodeId, toNodeId) {
        let transform = new DOMMatrix();
        let currentNodeId = fromNodeId;

        while (currentNodeId !== toNodeId) {
          currentNodeId = nodes[currentNodeId].next;
          if (!currentNodeId) break;
          transform = nodes[currentNodeId].transform.multiply(transform);
        }

        return transform;
      }

      function changeReferenceNodeForward() {
        const nextNodeId = nodes[referenceNodeId].next;
        if (nextNodeId) {
          // Calculate the visual transform of the next node before changing reference
          const visualTransformBefore = viewportTransform.multiply(
            getAccumulatedTransform(referenceNodeId, nextNodeId),
          );

          // Update reference node
          referenceNodeId = nextNodeId;

          // After changing reference, the next node is now at the origin (identity transform)
          const visualTransformAfter = new DOMMatrix();

          // Calculate the difference between before and after transforms
          const compensationTransform = visualTransformBefore.multiply(visualTransformAfter.inverse());

          // Adjust viewport transform to compensate exactly for the difference
          viewportTransform = compensationTransform;

          // Update the info panel
          document.getElementById('reference-node-info').textContent = `Reference node: ${referenceNodeId}`;

          // Redraw
          draw();
        }
      }

      function changeReferenceNodeBackward() {
        const prevNodeId = nodes[referenceNodeId].prev;
        if (prevNodeId) {
          // Get the transform from previous node to current node
          const nodeTransform = nodes[referenceNodeId].transform;

          // Calculate the current node's position in viewport before changing reference
          const visualTransformBefore = viewportTransform;

          // Update reference node (before applying transform changes)
          referenceNodeId = prevNodeId;

          // Apply the inverse of the node transform to maintain visual position
          viewportTransform = viewportTransform.multiply(invertTransform(nodeTransform));

          // Update the info panel
          document.getElementById('reference-node-info').textContent = `Reference node: ${referenceNodeId}`;

          // Redraw
          draw();
        }
      }

      function resetView() {
        // Reset to node1 and reset viewport transform
        referenceNodeId = 'node1';
        viewportTransform = new DOMMatrix().translate(0, 0).scale(1);

        // Update the info panel
        document.getElementById('reference-node-info').textContent = `Reference node: ${referenceNodeId}`;

        console.log('View reset to node1');

        // Redraw
        draw();
      }

      // Make globally accessible for the buttons
      window.changeReferenceNodeForward = changeReferenceNodeForward;
      window.changeReferenceNodeBackward = changeReferenceNodeBackward;
      window.resetView = resetView;

      // Initial draw
      draw();
    </script>
  </body>
</html>
