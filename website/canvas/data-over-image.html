<!doctype html>
<html lang="en-us">
  <head>
    <title>Data over Image</title>
    <style>
      * {
        box-sizing: border-box;
      }

      html,
      body {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        font-family: Arial, sans-serif;
        background-color: #f5f5f5;
        overflow-x: hidden;
      }

      .app-container {
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
      }

      .title {
        font-size: 28px;
        font-weight: bold;
        text-align: center;
        margin-bottom: 20px;
        color: #333;
      }

      .sender-section {
        background: white;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        padding: 20px;
        margin-bottom: 20px;
      }

      .receiver-section {
        background: white;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        padding: 20px;
        display: flex;
        flex-direction: column;
      }

      .section-title {
        font-size: 18px;
        margin-top: 0;
        margin-bottom: 15px;
        color: #333;
      }

      textarea {
        width: 100%;
        border-radius: 8px;
        border: 1px solid #ddd;
        padding: 12px;
        margin-bottom: 15px;
        font-size: 16px;
        resize: none;
      }

      button {
        padding: 10px 16px;
        background-color: #4caf50;
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 16px;
        transition: background-color 0.2s;
      }

      button:hover {
        background-color: #45a049;
      }

      .qr-container {
        display: flex;
        justify-content: center;
        margin: 20px 0;
      }

      #qrcode {
        background-color: white;
        padding: 15px;
        border-radius: 8px;
        text-align: center;
        width: 350px;
        height: 350px;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 1px solid #eee;
      }

      #qrcode canvas {
        max-width: 100%;
        max-height: 100%;
      }

      .camera-controls {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
      }

      .camera-container {
        display: flex;
        gap: 20px;
        align-items: flex-start;
      }

      #videoContainer {
        width: 200px;
        height: 200px;
        position: relative;
        overflow: hidden;
        background-color: #000;
        border-radius: 8px;
        flex-shrink: 0;
        cursor: pointer;
      }

      #video {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      #canvas {
        display: none;
      }

      .message-container {
        flex-grow: 1;
      }

      .status {
        margin-top: 10px;
        font-size: 14px;
        color: #666;
      }

      .camera-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: rgba(0, 0, 0, 0.5);
        border-radius: 8px;
        transition: opacity 0.3s ease;
      }

      .camera-label {
        color: white;
        font-size: 16px;
        font-weight: bold;
        text-align: center;
        padding: 10px;
        opacity: 1;
        visibility: visible;
      }

      /* Show stop camera text on hover when camera is active */
      .camera-active .camera-overlay {
        opacity: 0;
        visibility: hidden;
      }

      .camera-active:hover .camera-overlay {
        opacity: 1;
        visibility: visible;
        background-color: rgba(0, 0, 0, 0.7);
      }

      /* New styles for streaming controls */
      .streaming-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 15px;
      }

      .chunk-controls {
        display: flex;
        gap: 10px;
      }

      .chunk-info {
        font-size: 14px;
        color: #666;
        display: flex;
        align-items: center;
      }

      .chunk-size-control {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .chunk-size-control label {
        font-size: 14px;
        color: #666;
      }

      .chunk-size-control input {
        width: 60px;
        padding: 5px;
        border-radius: 4px;
        border: 1px solid #ddd;
      }

      .progress-bar-container {
        height: 10px;
        background-color: #eee;
        border-radius: 5px;
        margin-top: 10px;
        overflow: hidden;
      }

      .progress-bar {
        height: 100%;
        background-color: #4caf50;
        width: 0%;
        transition: width 0.3s ease;
      }

      .received-chunks {
        margin-top: 10px;
        font-size: 14px;
        color: #666;
      }
    </style>
  </head>
  <body>
    <div class="app-container">
      <div class="title">Data over Image</div>

      <!-- Sender Section -->
      <div class="sender-section">
        <h3 class="section-title">Send Message</h3>
        <textarea id="txData" style="height: 80px">Hello from Folk Canvas!</textarea>

        <div class="chunk-size-control">
          <label for="chunkSize">Chunk Size (bytes):</label>
          <input type="number" id="chunkSize" min="10" max="500" value="100" />
          <button id="chunkDataBtn">Chunk Data</button>
        </div>

        <div class="qr-container">
          <div id="qrcode"></div>
        </div>

        <div class="streaming-controls">
          <div class="chunk-controls">
            <button id="prevChunkBtn" disabled>Previous Chunk</button>
            <button id="nextChunkBtn" disabled>Next Chunk</button>
          </div>
          <div class="chunk-info">
            <span id="chunkCounter">0/0</span>
          </div>
        </div>

        <div class="progress-bar-container">
          <div id="sendProgressBar" class="progress-bar"></div>
        </div>
      </div>

      <!-- Receiver Section -->
      <div class="receiver-section">
        <h3 class="section-title">Receive Message</h3>
        <div class="camera-container">
          <div id="videoContainer">
            <video id="video" playsinline></video>
            <div id="cameraOverlay" class="camera-overlay">
              <div class="camera-label">Start Camera</div>
            </div>
          </div>
          <div class="message-container">
            <textarea id="rxData" style="height: 200px" disabled></textarea>
            <div class="status" id="scanStatus">Ready to scan</div>
            <div class="received-chunks" id="receivedChunks">Received: 0/0 chunks</div>
            <div class="progress-bar-container">
              <div id="receiveProgressBar" class="progress-bar"></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <canvas id="canvas"></canvas>

    <!-- QR Code libraries -->
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.1/build/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
    <!-- Crypto library for hashing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>

    <script type="text/javascript">
      // DOM elements
      const txData = document.getElementById('txData');
      const rxData = document.getElementById('rxData');
      const qrcodeContainer = document.getElementById('qrcode');
      const video = document.getElementById('video');
      const canvas = document.getElementById('canvas');
      const videoContainer = document.getElementById('videoContainer');
      const cameraOverlay = document.getElementById('cameraOverlay');
      const cameraLabel = cameraOverlay.querySelector('.camera-label');
      const scanStatus = document.getElementById('scanStatus');
      const chunkSizeInput = document.getElementById('chunkSize');
      const chunkDataBtn = document.getElementById('chunkDataBtn');
      const prevChunkBtn = document.getElementById('prevChunkBtn');
      const nextChunkBtn = document.getElementById('nextChunkBtn');
      const chunkCounter = document.getElementById('chunkCounter');
      const receivedChunks = document.getElementById('receivedChunks');
      const sendProgressBar = document.getElementById('sendProgressBar');
      const receiveProgressBar = document.getElementById('receiveProgressBar');

      // Variables for video scanning
      let videoStream = null;
      let scanInterval = null;
      let cameraActive = false;
      const canvasContext = canvas.getContext('2d');

      // Variables for data streaming
      let dataChunks = [];
      let currentChunkIndex = 0;
      let receivedChunksData = [];
      let receivedChunksMap = new Map();
      let lastReceivedHash = '';
      let totalChunks = 0;

      // Function to chunk data
      function chunkData() {
        const text = txData.value.trim();
        if (!text) return;

        const chunkSize = parseInt(chunkSizeInput.value, 10);
        if (isNaN(chunkSize) || chunkSize < 10) {
          alert('Please enter a valid chunk size (minimum 10 bytes)');
          return;
        }

        // Reset variables
        dataChunks = [];
        currentChunkIndex = 0;

        // Split text into chunks
        for (let i = 0; i < text.length; i += chunkSize) {
          const chunk = text.substring(i, i + chunkSize);
          dataChunks.push(chunk);
        }

        totalChunks = dataChunks.length;

        // Update UI
        updateChunkCounter();
        prevChunkBtn.disabled = true;
        nextChunkBtn.disabled = totalChunks <= 1;

        // Generate QR code for first chunk
        if (totalChunks > 0) {
          generateQRCodeForCurrentChunk();
        }
      }

      // Update chunk counter display
      function updateChunkCounter() {
        if (dataChunks.length === 0) {
          chunkCounter.textContent = '0/0';
          sendProgressBar.style.width = '0%';
        } else {
          chunkCounter.textContent = `${currentChunkIndex + 1}/${totalChunks}`;
          sendProgressBar.style.width = `${((currentChunkIndex + 1) / totalChunks) * 100}%`;
        }
      }

      // Generate hash for a chunk
      function generateChunkHash(chunk, index) {
        // Create a hash of the chunk content and its index
        return CryptoJS.SHA256(`${index}:${chunk}`).toString(CryptoJS.enc.Hex).substring(0, 8);
      }

      // Generate QR code for current chunk
      function generateQRCodeForCurrentChunk() {
        qrcodeContainer.innerHTML = '';

        if (dataChunks.length === 0 || currentChunkIndex >= dataChunks.length) {
          return;
        }

        const chunk = dataChunks[currentChunkIndex];
        const hash = generateChunkHash(chunk, currentChunkIndex);

        // Format: CHUNK:index:total:hash:data
        const qrData = `CHUNK:${currentChunkIndex}:${totalChunks}:${hash}:${chunk}`;

        // Create a new canvas element inside the container
        const canvas = document.createElement('canvas');
        qrcodeContainer.appendChild(canvas);

        QRCode.toCanvas(
          canvas,
          qrData,
          {
            width: 320,
            margin: 1,
            color: {
              dark: '#000',
              light: '#fff',
            },
          },
          function (error) {
            if (error) console.error(error);
          },
        );
      }

      // Generate QR code for acknowledgment
      function generateAckQRCode(hash) {
        qrcodeContainer.innerHTML = '';

        // Format: ACK:hash
        const qrData = `ACK:${hash}`;

        // Create a new canvas element inside the container
        const canvas = document.createElement('canvas');
        qrcodeContainer.appendChild(canvas);

        QRCode.toCanvas(
          canvas,
          qrData,
          {
            width: 320,
            margin: 1,
            color: {
              dark: '#000',
              light: '#fff',
            },
          },
          function (error) {
            if (error) console.error(error);
          },
        );
      }

      // Navigate to previous chunk
      function goToPrevChunk() {
        if (currentChunkIndex > 0) {
          currentChunkIndex--;
          updateChunkCounter();
          generateQRCodeForCurrentChunk();

          // Update button states
          prevChunkBtn.disabled = currentChunkIndex === 0;
          nextChunkBtn.disabled = false;
        }
      }

      // Navigate to next chunk
      function goToNextChunk() {
        if (currentChunkIndex < dataChunks.length - 1) {
          currentChunkIndex++;
          updateChunkCounter();
          generateQRCodeForCurrentChunk();

          // Update button states
          prevChunkBtn.disabled = false;
          nextChunkBtn.disabled = currentChunkIndex === dataChunks.length - 1;
        }
      }

      // Process received QR code data
      function processQRData(data) {
        // Check if it's a chunk
        if (data.startsWith('CHUNK:')) {
          const parts = data.split(':');
          if (parts.length >= 5) {
            const index = parseInt(parts[1], 10);
            const total = parseInt(parts[2], 10);
            const hash = parts[3];
            // Reconstruct the chunk data (in case it contains colons)
            const chunkData = parts.slice(4).join(':');

            // Verify hash
            const calculatedHash = generateChunkHash(chunkData, index);
            if (calculatedHash === hash) {
              // Store the chunk
              if (!receivedChunksMap.has(index)) {
                receivedChunksMap.set(index, chunkData);
                lastReceivedHash = hash;

                // Update UI
                updateReceivedChunks(total);

                // Generate acknowledgment QR code
                generateAckQRCode(hash);

                // If all chunks received, combine them
                if (receivedChunksMap.size === total) {
                  combineReceivedChunks(total);
                }
              }
            }
          }
        }
        // Check if it's an acknowledgment
        else if (data.startsWith('ACK:')) {
          const parts = data.split(':');
          if (parts.length >= 2) {
            const hash = parts[1];
            const currentChunkHash = generateChunkHash(dataChunks[currentChunkIndex], currentChunkIndex);

            // If the hash matches the current chunk, move to the next one
            if (hash === currentChunkHash && currentChunkIndex < dataChunks.length - 1) {
              goToNextChunk();
            }
          }
        }
      }

      // Update received chunks display
      function updateReceivedChunks(total) {
        receivedChunks.textContent = `Received: ${receivedChunksMap.size}/${total} chunks`;
        receiveProgressBar.style.width = `${(receivedChunksMap.size / total) * 100}%`;
      }

      // Combine received chunks into complete message
      function combineReceivedChunks(total) {
        let combinedData = '';
        for (let i = 0; i < total; i++) {
          if (receivedChunksMap.has(i)) {
            combinedData += receivedChunksMap.get(i);
          }
        }

        // Display the complete message
        rxData.value = combinedData;
        scanStatus.textContent = 'All chunks received!';
      }

      // Generate QR code from text input (original function, now used for single messages)
      function generateQRCode() {
        qrcodeContainer.innerHTML = '';
        const text = txData.value.trim();

        if (text) {
          // Create a new canvas element inside the container
          const canvas = document.createElement('canvas');
          qrcodeContainer.appendChild(canvas);

          QRCode.toCanvas(
            canvas,
            text,
            {
              width: 320,
              margin: 1,
              color: {
                dark: '#000',
                light: '#fff',
              },
            },
            function (error) {
              if (error) console.error(error);
            },
          );
        }
      }

      // Toggle camera on/off when clicking the video container
      videoContainer.addEventListener('click', function () {
        if (cameraActive) {
          stopCamera();
        } else {
          startCamera();
        }
      });

      // Start camera for QR code scanning
      function startCamera() {
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
          navigator.mediaDevices
            .getUserMedia({
              video: { facingMode: 'user' }, // Use front camera
            })
            .then(function (stream) {
              videoStream = stream;
              video.srcObject = stream;
              video.setAttribute('playsinline', true);
              video.play();

              // Set canvas size to match video dimensions
              video.onloadedmetadata = function () {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
              };

              // Start scanning for QR codes
              scanStatus.textContent = 'Scanning...';
              scanInterval = setInterval(scanQrCode, 200);

              // Update UI to show camera is active
              cameraActive = true;
              videoContainer.classList.add('camera-active');
              cameraLabel.textContent = 'Stop Camera';

              // Reset received chunks when starting camera
              receivedChunksMap = new Map();
              updateReceivedChunks(0);
            })
            .catch(function (error) {
              console.error('Camera error:', error);
              scanStatus.textContent = 'Camera access error: ' + error.message;
            });
        } else {
          scanStatus.textContent = 'Camera not supported on this device/browser';
        }
      }

      // Stop camera scanning
      function stopCamera() {
        if (videoStream) {
          videoStream.getTracks().forEach((track) => track.stop());
          videoStream = null;
        }

        if (scanInterval) {
          clearInterval(scanInterval);
          scanInterval = null;
        }

        // Update UI to show camera is inactive
        cameraActive = false;
        videoContainer.classList.remove('camera-active');
        cameraLabel.textContent = 'Start Camera';
        scanStatus.textContent = 'Ready to scan';
      }

      // Function to scan video frame for QR codes
      function scanQrCode() {
        if (video.readyState === video.HAVE_ENOUGH_DATA) {
          // Set canvas dimensions
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;

          // Draw video frame to canvas
          canvasContext.drawImage(video, 0, 0, canvas.width, canvas.height);

          // Get image data from canvas
          const imageData = canvasContext.getImageData(0, 0, canvas.width, canvas.height);

          // Scan for QR code
          const code = jsQR(imageData.data, imageData.width, imageData.height, {
            inversionAttempts: 'dontInvert',
          });

          // If QR code found
          if (code) {
            // Process the QR code data
            processQRData(code.data);

            // Display feedback
            scanStatus.textContent = 'QR Code detected!';

            // Add a quick visual feedback
            setTimeout(() => {
              scanStatus.textContent = 'Scanning...';
            }, 1000);
          }
        }
      }

      // Event listeners
      txData.addEventListener('input', function () {
        // Reset chunks when text changes
        dataChunks = [];
        currentChunkIndex = 0;
        updateChunkCounter();
        prevChunkBtn.disabled = true;
        nextChunkBtn.disabled = true;

        // Generate single QR code for the text
        generateQRCode();
      });

      chunkDataBtn.addEventListener('click', chunkData);
      prevChunkBtn.addEventListener('click', goToPrevChunk);
      nextChunkBtn.addEventListener('click', goToNextChunk);

      // Initial QR code generation
      generateQRCode();
    </script>
  </body>
</html>
