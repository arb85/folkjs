<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hypertext ZUI</title>
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        overflow: hidden;
        background: #f9f9f9;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      }

      #info-container {
        position: absolute;
        bottom: 15px;
        right: 15px;
        background-color: rgba(255, 255, 255, 0.9);
        padding: 12px 15px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        z-index: 2000;
        max-width: 300px;
        font-size: 12px;
        line-height: 1.4;
        backdrop-filter: blur(5px);
        border: 1px solid rgba(220, 220, 220, 0.5);

        & > div:first-child {
          font-weight: bold;
          margin-bottom: 5px;
        }
      }

      #zui-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      .node {
        position: absolute;
        transform-origin: center;
        display: flex;
        justify-content: center;
        align-items: center;
        font-weight: bold;
        color: white;
        border: none;
        border-radius: 12px;
        box-sizing: border-box;
        user-select: none;
        font-size: 14px;
        box-shadow:
          0 8px 25px rgba(0, 0, 0, 0.3),
          0 2px 5px rgba(0, 0, 0, 0.2);
        overflow: hidden;
      }

      .node-content {
        padding: 50px 25px 20px;
        width: 100%;
        height: 100%;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        text-align: left;
        position: relative;
        justify-content: flex-start;
      }

      .node h3 {
        margin: 0 0 15px 0;
        font-size: 1.5em;
        border-bottom: 1px solid rgba(255, 255, 255, 0.3);
        width: 100%;
        padding-bottom: 8px;
        letter-spacing: 0.02em;
      }

      .node p {
        margin: 0 0 15px 0;
        font-size: 0.9em;
        line-height: 1.5;
      }

      /* Wiki-style formatting */
      .wiki-content {
        font-family: 'Georgia', serif;
        font-size: 15px;
      }

      .wiki-content .summary {
        font-style: italic;
        border-left: 3px solid rgba(255, 255, 255, 0.5);
        padding-left: 15px;
        margin-bottom: 20px;
        line-height: 1.6;
        color: rgba(255, 255, 255, 0.95);
      }

      .wiki-content h4 {
        margin: 20px 0 10px 0;
        font-size: 1.1em;
        font-family: 'Georgia', serif;
        font-weight: bold;
        letter-spacing: 0.02em;
      }

      /* Links should be invisible but maintain dimensions */
      .zui-link {
        display: block;
        position: relative;
        width: 100px;
        height: 60px; /* Maintain the same 5:3 aspect ratio */
        margin: 10px 0;
        opacity: 0;
        background-color: transparent;
        border: none;
        cursor: default;
        /* Keep the same aspect ratio as nodes */
        aspect-ratio: 5/3;
        /* No interaction */
        pointer-events: none;
        /* Make invisible but keep space */
        color: transparent;
        font-size: 0;
        text-decoration: none;
      }
    </style>
  </head>
  <body>
    <div id="info-container">
      <div>Infinite Knowledge Explorer</div>
      <div>Navigate through an interconnected wiki using an infinite zoom interface.</div>
      <br />
      <div> <kbd>Shift</kbd> to zoom in &nbsp;|&nbsp; <kbd>Alt+Shift</kbd> to zoom out </div>
      <div id="reference-node-info" style="margin-top: 8px; font-style: italic">coordinate frame: nodeA</div>
    </div>

    <div id="zui-container"></div>

    <script type="module">
      import { FloatingOriginGraph } from '@labs/FloatingOriginGraph.ts';

      // Define constants for node dimensions
      const NODE_WIDTH = 500 * 2;
      const NODE_HEIGHT = 300 * 2;

      // Define nodes as an array for our simple 3-node cycle
      const nodesArray = [
        {
          id: 'nodeA',
          data: {
            color: 'rgba(70, 50, 100, 0.95)',
            content: `
              <div class="wiki-content">
                <h3>Aetheria</h3>
                <div class="summary">A floating city-state in the upper atmosphere of Jovian-9, renowned for its advanced teleportation technology and crystalline architecture.</div>
                
                <p>Established in 2387 as a scientific research outpost, Aetheria evolved into a sovereign technological haven within decades. The city hovers within the upper cloud layers of Jovian-9, protected by a powerful energy field that maintains Earth-like conditions within its boundaries.</p>
                
                <h4>Notable Locations</h4>
                <p>The <strong>Central Nexus</strong> serves as both governmental center and research facility. The sprawling <strong>Cloudwalker District</strong> houses most of the 50,000 permanent residents, while the <strong>Prism Gardens</strong> feature exotic flora that thrive in the unusual atmospheric conditions.</p>
                
                <h4>Related Topics</h4>
                <a href="#" class="zui-link" data-target="nodeB">Quantum Foldspace</a>
                <a href="#" class="zui-link" data-target="nodeC">The Mist Sovereigns</a>
              </div>
            `,
          },
        },
        {
          id: 'nodeB',
          data: {
            color: 'rgba(40, 80, 120, 0.95)',
            content: `
              <div class="wiki-content">
                <h3>Quantum Foldspace</h3>
                <div class="summary">A theoretical dimension that enables near-instantaneous travel between distant points in conventional space-time through dimensional compression.</div>
                
                <p>First theorized by Dr. Elara Venn in 2412, Quantum Foldspace exists as a parallel dimension where conventional space-time is compressed to an extraordinary degree. Aetherian scientists developed the revolutionary Venn-Katori apparatus that creates temporary "folds" in reality, allowing matter to traverse vast distances through this dimensional shortcut.</p>
                
                <h4>Observable Properties</h4>
                <p>To human observers, Foldspace appears as a luminescent azure void with visible ripples of energy that correspond to gravitational waves in normal space. Physical laws differ significantly from our universe, with time dilation effects making a typical journey feel subjectively instantaneous regardless of the objective distance covered.</p>
                
                <h4>Related Topics</h4>
                <a href="#" class="zui-link" data-target="nodeC">The Mist Sovereigns</a>
              </div>
            `,
          },
        },
        {
          id: 'nodeC',
          data: {
            color: 'rgba(60, 100, 70, 0.95)',
            content: `
              <div class="wiki-content">
                <h3>The Mist Sovereigns</h3>
                <div class="summary">A collective intelligence of sentient gaseous entities native to the lower atmosphere of Jovian-9, capable of manipulating atmospheric conditions with remarkable precision.</div>
                
                <p>First contacted in 2430, the Mist Sovereigns are a distributed consciousness composed of billions of specialized ionized gas particles that form a collective mind. They communicate through complex patterns of modulated electrical discharges that Aetherian linguists have only partially decoded. Individual Sovereigns can extend across hundreds of kilometers but typically condense to more localized forms when interacting with humans.</p>
                
                <h4>Relations with Aetheria</h4>
                <p>Initial encounters were marked by hostility as the Sovereigns perceived Aetherian energy fields as an intrusion into their domain. After the Diplomatic Crisis of 2433, a cautious alliance was established. The Sovereigns now maintain a complex symbiotic relationship with Aetheria, exchanging their unparalleled knowledge of atmospheric science for limited access to foldspace technology, which they use to explore distant gas giants.</p>
                
                <h4>Related Topics</h4>
                <a href="#" class="zui-link" data-target="nodeA">Aetheria</a>
              </div>
            `,
          },
        },
      ];

      // Function to create a node element
      function createNodeElement(nodeId, instanceId) {
        const node = graph.nodes[nodeId];
        if (!node) return null;

        const nodeElement = document.createElement('div');
        nodeElement.classList.add('node');
        nodeElement.id = `node-${nodeId}-${instanceId}`;
        nodeElement.dataset.nodeId = nodeId;
        nodeElement.dataset.instanceId = instanceId;
        nodeElement.style.width = `${NODE_WIDTH}px`;
        nodeElement.style.height = `${NODE_HEIGHT}px`;
        nodeElement.style.backgroundColor = node.data.color;

        // Create a content container
        const contentElement = document.createElement('div');
        contentElement.classList.add('node-content');

        // Use HTML content if available
        if (node.data.content) {
          contentElement.innerHTML = node.data.content;
        } else {
          contentElement.textContent = nodeId;
        }

        // Setup links to prevent default behavior and remove visual indicators
        const links = contentElement.querySelectorAll('.zui-link');
        links.forEach((link) => {
          link.addEventListener('click', (e) => {
            e.preventDefault();
          });

          // Just set the title without adding any visual elements
          const targetId = link.dataset.target;
          if (targetId) {
            link.title = `Links to: ${targetId}`;
            // No longer adding any visual label
          }
        });

        nodeElement.appendChild(contentElement);
        return nodeElement;
      }

      /**
       * Calculates relative position of a link within its parent node
       * @param {HTMLElement} linkElement - The link element
       * @param {HTMLElement} nodeElement - The parent node element
       * @returns {Object} - The relative position and size data
       */
      function getLinkPosition(linkElement, nodeElement) {
        const nodeRect = nodeElement.getBoundingClientRect();
        const linkRect = linkElement.getBoundingClientRect();

        // Calculate relative position (0-1) within the node
        const x = (linkRect.left + linkRect.width / 2 - nodeRect.left) / nodeRect.width;
        const y = (linkRect.top + linkRect.height / 2 - nodeRect.top) / nodeRect.height;

        // Calculate relative size (0-1) compared to the node
        const width = linkRect.width / nodeRect.width;
        const height = linkRect.height / nodeRect.height;

        return { x, y, width, height };
      }

      /**
       * Converts link position to a transform matrix
       * @param {Object} linkPosition - The relative position and size data
       * @returns {DOMMatrix} - The resulting transform matrix
       */
      function linkPositionToTransform(linkPosition) {
        // Calculate the scale factor to make the target node exactly match the link size
        // We need to scale the node (NODE_WIDTH x NODE_HEIGHT) to match the link's dimensions
        const scaleX = linkPosition.width;
        const scaleY = linkPosition.height;

        // The link's center position in the node's coordinate system
        // Convert from relative coordinates (where linkPosition.x,linkPosition.y is the relative center)
        // to the coordinate system of the source node (where 0,0 is center)
        const translateX = (linkPosition.x - 0.5) * NODE_WIDTH;
        const translateY = (linkPosition.y - 0.5) * NODE_HEIGHT;

        // Create the transform matrix
        // First translate to position, then scale to match the link's size
        return new DOMMatrix().translate(translateX, translateY).scale(scaleX, scaleY);
      }

      // Setup temporary DOM to find links and build the edge map
      function buildEdgesFromLinks() {
        // Create a temporary container
        const tempContainer = document.createElement('div');
        tempContainer.style.position = 'absolute';
        tempContainer.style.visibility = 'hidden';
        tempContainer.style['pointer-events'] = 'none';
        document.body.appendChild(tempContainer);

        // Generate the edges array
        const edges = [];
        const renderedNodes = {};

        // First, create a DOM element for each node
        for (const node of nodesArray) {
          const nodeElement = document.createElement('div');
          nodeElement.classList.add('node');
          nodeElement.style.width = `${NODE_WIDTH}px`;
          nodeElement.style.height = `${NODE_HEIGHT}px`;

          const contentElement = document.createElement('div');
          contentElement.classList.add('node-content');
          contentElement.innerHTML = node.data.content;

          nodeElement.appendChild(contentElement);
          tempContainer.appendChild(nodeElement);
          renderedNodes[node.id] = nodeElement;
        }

        // Force layout calculation
        void tempContainer.offsetHeight;

        // Now find all links and calculate their positions
        for (const [nodeId, nodeElement] of Object.entries(renderedNodes)) {
          const links = nodeElement.querySelectorAll('.zui-link');

          links.forEach((link) => {
            const targetId = link.dataset.target;
            if (!targetId || !renderedNodes[targetId]) return;

            // Get the link's position relative to its parent node
            const linkPosition = getLinkPosition(link, nodeElement);

            // Convert to a transform matrix
            const transform = linkPositionToTransform(linkPosition);

            // Add to edges array
            edges.push({
              source: nodeId,
              target: targetId,
              transform,
            });
          });
        }

        // Clean up
        document.body.removeChild(tempContainer);

        return edges;
      }

      // First, build edges from links in node content
      const edgesArray = buildEdgesFromLinks();

      const MAX_VISIBLE_NODES = 20;
      const container = document.getElementById('zui-container');

      // Create the floating origin graph with our nodes and edges
      const graph = new FloatingOriginGraph(nodesArray, edgesArray, 'nodeA');

      // Define zoom threshold callbacks
      function shouldZoomInToNextNode(graph, containerWidth, containerHeight, nextNodeId) {
        const nextNode = graph.nodes[nextNodeId];
        if (!nextNode) return false;

        // Get the transform from reference node to next node
        const nextNodeTransform = graph.getAccumulatedTransform(nextNodeId);
        if (!nextNodeTransform) return false;

        // Calculate effective transform from combined viewport and node transform
        const combinedTransform = graph.viewportTransform.multiply(nextNodeTransform);

        // Check if screen is completely covered by the node
        return isScreenCoveredByRectangle(
          -NODE_WIDTH / 2,
          -NODE_HEIGHT / 2,
          NODE_WIDTH,
          NODE_HEIGHT,
          combinedTransform,
          containerWidth,
          containerHeight,
        );
      }

      function shouldZoomOutToPrevNode(graph, containerWidth, containerHeight, prevNodeId) {
        const currentNode = graph.referenceNode;
        if (!currentNode) return false;

        // For zooming out, we check if the current reference node no longer covers the screen
        return !isScreenCoveredByRectangle(
          -NODE_WIDTH / 2,
          -NODE_HEIGHT / 2,
          NODE_WIDTH,
          NODE_HEIGHT,
          graph.viewportTransform,
          containerWidth,
          containerHeight,
        );
      }

      /**
       * Checks if a rectangle completely covers the screen, even when transformed (rotated/scaled)
       * @param rectX - The x coordinate of the top-left of the rectangle (in its own coordinate system)
       * @param rectY - The y coordinate of the top-left of the rectangle (in its own coordinate system)
       * @param width - The width of the rectangle
       * @param height - The height of the rectangle
       * @param transform - The transformation to apply to the rectangle
       * @param containerWidth - The width of the container
       * @param containerHeight - The height of the container
       * @returns True if the rectangle completely covers the screen
       */
      function isScreenCoveredByRectangle(rectX, rectY, width, height, transform, containerWidth, containerHeight) {
        // We'll check multiple points along the screen edges to see if they're all inside the transformed rectangle
        // For better accuracy, we sample more points for larger screens
        const numPointsToCheck = Math.max(5, Math.min(20, Math.floor(Math.max(containerWidth, containerHeight) / 50)));

        // Create test points along the screen edges and interior
        const testPoints = [];

        // Add the four corners of the screen
        testPoints.push({ x: 0, y: 0 }); // Top-left
        testPoints.push({ x: containerWidth, y: 0 }); // Top-right
        testPoints.push({ x: containerWidth, y: containerHeight }); // Bottom-right
        testPoints.push({ x: 0, y: containerHeight }); // Bottom-left

        // Add points along the edges of the screen
        for (let i = 1; i < numPointsToCheck - 1; i++) {
          const t = i / (numPointsToCheck - 1);
          // Top edge
          testPoints.push({ x: t * containerWidth, y: 0 });
          // Right edge
          testPoints.push({ x: containerWidth, y: t * containerHeight });
          // Bottom edge
          testPoints.push({ x: (1 - t) * containerWidth, y: containerHeight });
          // Left edge
          testPoints.push({ x: 0, y: (1 - t) * containerHeight });
        }

        // Add some interior points
        for (let i = 1; i < numPointsToCheck - 1; i++) {
          for (let j = 1; j < numPointsToCheck - 1; j++) {
            const x = (i / (numPointsToCheck - 1)) * containerWidth;
            const y = (j / (numPointsToCheck - 1)) * containerHeight;
            testPoints.push({ x, y });
          }
        }

        // Calculate the corners of the rectangle in its local coordinate system
        const rectCorners = [
          { x: rectX, y: rectY }, // Top-left
          { x: rectX + width, y: rectY }, // Top-right
          { x: rectX + width, y: rectY + height }, // Bottom-right
          { x: rectX, y: rectY + height }, // Bottom-left
        ];

        // Transform the rectangle corners to screen space
        const transformedRectCorners = rectCorners.map((corner) => {
          const pt = new DOMPoint(corner.x, corner.y);
          const transformedPt = pt.matrixTransform(transform);
          return {
            x: transformedPt.x + containerWidth / 2,
            y: transformedPt.y + containerHeight / 2,
          };
        });

        // Verify that all test points are inside the transformed rectangle
        for (const point of testPoints) {
          if (!isPointInPolygon(point, transformedRectCorners)) {
            return false;
          }
        }

        return true;
      }

      /**
       * Checks if a point is inside a polygon using the ray casting algorithm
       * @param point - The point to check
       * @param polygon - Array of points forming the polygon
       * @returns True if the point is inside the polygon
       */
      function isPointInPolygon(point, polygon) {
        let inside = false;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
          const xi = polygon[i].x,
            yi = polygon[i].y;
          const xj = polygon[j].x,
            yj = polygon[j].y;

          const intersect = yi > point.y !== yj > point.y && point.x < ((xj - xi) * (point.y - yi)) / (yj - yi) + xi;
          if (intersect) inside = !inside;
        }
        return inside;
      }

      // Function to update the DOM based on the current graph state
      function updateDOM() {
        // Get container dimensions for centering
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;

        // Clear the container
        container.innerHTML = '';

        // Counter for generating unique instance IDs
        let instanceCounter = 0;

        // Process all visible nodes
        for (const { nodeId, node, transform } of graph.getVisibleNodesWithTransforms(MAX_VISIBLE_NODES)) {
          // Create a unique instance ID for this occurrence of the node
          const instanceId = instanceCounter++;

          // Create a new DOM element for this instance of the node
          const nodeElement = createNodeElement(nodeId, instanceId);
          if (!nodeElement) continue;

          // Add to container
          container.appendChild(nodeElement);

          // Combine viewport transform with the node's transform
          const combinedTransform = graph.viewportTransform.multiply(transform);

          // Calculate the position in the container
          // In FloatingOriginGraph, nodes are positioned at the center of the container
          const translateX = containerWidth / 2 + combinedTransform.e;
          const translateY = containerHeight / 2 + combinedTransform.f;

          // Extract scale and rotation from the transform
          const scale = combinedTransform.a; // Assuming uniform scaling

          // Create a CSS transform
          // The order is important: first translate to center, then apply the transform
          const cssTransform = `
            translate(-50%, -50%)
            translate(${translateX}px, ${translateY}px)
            scale(${scale})
          `;

          // Apply the transform
          nodeElement.style.transform = cssTransform;
        }

        // Update reference node info display
        document.getElementById('reference-node-info').textContent = `coordinate frame: ${graph.referenceNodeId}`;
      }

      // Handle window resizing
      function handleResize() {
        updateDOM();
      }

      // Pan handling
      let isDragging = false;
      let lastX = 0;
      let lastY = 0;

      // Add mouse position tracking
      let currentMouseX = container.clientWidth / 2;
      let currentMouseY = container.clientHeight / 2;

      function setupEventListeners() {
        // Mouse down for panning
        container.addEventListener('mousedown', (e) => {
          // Prevent zooming when clicking on links
          if (e.target.classList.contains('zui-link')) {
            e.preventDefault();
            return;
          }

          isDragging = true;
          lastX = e.clientX;
          lastY = e.clientY;
          container.style.cursor = 'grabbing';
        });

        // Mouse move for panning and tracking
        container.addEventListener('mousemove', (e) => {
          currentMouseX = e.clientX;
          currentMouseY = e.clientY;

          if (isDragging) {
            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;

            // Update viewport transform for panning
            graph.pan(dx, dy);

            lastX = e.clientX;
            lastY = e.clientY;

            updateDOM();
          }
        });

        // Mouse up to end panning
        window.addEventListener('mouseup', () => {
          if (isDragging) {
            isDragging = false;
            container.style.cursor = 'default';
          }
        });

        // Wheel for zooming
        container.addEventListener(
          'wheel',
          (e) => {
            e.preventDefault();

            // Calculate zoom factor
            const zoomFactor = e.deltaY > 0 ? 0.95 : 1.05;

            // Get mouse position relative to container center
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            const mouseX = e.clientX - containerWidth / 2;
            const mouseY = e.clientY - containerHeight / 2;

            // Apply zoom centered on mouse position and check if reference node changed
            const referenceChanged = graph.zoomAtPoint(
              mouseX,
              mouseY,
              zoomFactor,
              containerWidth,
              containerHeight,
              shouldZoomInToNextNode,
              shouldZoomOutToPrevNode,
            );

            updateDOM();
          },
          { passive: false },
        );

        // Keyboard events for continuous zooming
        window.addEventListener('keydown', (e) => {
          if (e.shiftKey && !e.altKey && !isShiftZooming) {
            isShiftZooming = true;
            startContinuousZoom(true);
          } else if (e.shiftKey && e.altKey && !isAltShiftZooming) {
            isAltShiftZooming = true;
            startContinuousZoom(false);
          }
        });

        window.addEventListener('keyup', (e) => {
          if (!e.shiftKey || (isAltShiftZooming && !e.altKey)) {
            isShiftZooming = false;
            isAltShiftZooming = false;
            stopContinuousZoom();
          }
        });

        // Window resize handler
        window.addEventListener('resize', handleResize);
      }

      // Continuous zoom variables and functions
      let isShiftZooming = false;
      let isAltShiftZooming = false;
      let zoomAnimationId = null;
      let isZooming = false;
      let zoomDirection = 1;

      function startContinuousZoom(zoomIn) {
        stopContinuousZoom(); // Cancel any existing animation

        isZooming = true;
        zoomDirection = zoomIn ? 1 : -1;

        // Start the animation loop
        animateZoom();
      }

      function animateZoom() {
        if (!isZooming) return;

        // Calculate zoom factor based on direction
        const zoomFactor = zoomDirection > 0 ? 1.02 : 0.98;

        // Get mouse position relative to container center
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;
        const mouseX = currentMouseX - containerWidth / 2;
        const mouseY = currentMouseY - containerHeight / 2;

        // Apply zoom centered on mouse position and check if reference node changed
        const referenceChanged = graph.zoomAtPoint(
          mouseX,
          mouseY,
          zoomFactor,
          containerWidth,
          containerHeight,
          shouldZoomInToNextNode,
          shouldZoomOutToPrevNode,
        );

        updateDOM();

        // Continue the animation loop
        zoomAnimationId = requestAnimationFrame(animateZoom);
      }

      function stopContinuousZoom() {
        isZooming = false;
        if (zoomAnimationId) {
          cancelAnimationFrame(zoomAnimationId);
          zoomAnimationId = null;
        }
      }

      // Initialize and start the application
      function init() {
        setupEventListeners();
        updateDOM();
      }

      // Start the application
      init();
    </script>
  </body>
</html>
