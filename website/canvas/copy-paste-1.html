<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>folk-space element - Copy-Paste Demo</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Recursive:slnt,wght,CASL,CRSV,MONO@-15..0,300..1000,0..1,0..1,0..1&display=swap"
      rel="stylesheet"
    />
    <style>
      /* Base styles */
      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
        overscroll-behavior-x: none;
        touch-action: none;
      }

      folk-space {
        width: 100%;
        height: 100%;
        background-color: #f8f9fa;
      }

      folk-shape {
        background-color: #3498db;
        border-radius: 5px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      }

      .status {
        position: fixed;
        bottom: 10px;
        left: 10px;
        background: white;
        padding: 10px;
        border-radius: 5px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        z-index: 1000;
        font-size: 14px;
        color: #333;
      }

      .selected {
        outline: 2px solid #e74c3c !important;
      }
    </style>
  </head>
  <body>
    <div class="status" id="status"
      >Use SHIFT+click to select multiple elements. Copy with Ctrl+C/Cmd+C, paste with Ctrl+V/Cmd+V.</div
    >

    <folk-space id="space">
      <folk-shape id="box1" x="100" y="100" width="100" height="100"></folk-shape>
      <folk-shape id="box2" x="300" y="200" width="80" height="80"></folk-shape>
      <folk-shape id="box3" x="500" y="300" width="120" height="120"></folk-shape>
      <folk-shape id="box4" x="200" y="400" width="150" height="150">
        Lets add some long content to check scrolling behaviour. Lorem ipsum dolor sit amet consectetur adipisicing
        elit. Quisquam, quos. Lorem ipsum dolor sit amet consectetur adipisicing elit. Quisquam, quos. Lorem ipsum dolor
        sit amet consectetur adipisicing elit. Quisquam, quos. Lorem ipsum dolor sit amet consectetur adipisicing elit.
        Quisquam, quos. Lorem ipsum dolor sit amet consectetur adipisicing elit. Quisquam, quos. Lorem ipsum dolor sit
        amet consectetur adipisicing elit. Quisquam, quos. Lorem ipsum dolor sit amet consectetur adipisicing elit.
        Quisquam, quos. Lorem ipsum dolor sit amet consectetur adipisicing elit. Quisquam, quos.
      </folk-shape>
    </folk-space>

    <script type="module">
      import '@labs/standalone/folk-space.ts';
      import '@labs/standalone/folk-shape.ts';

      // Add importSrc static property to custom elements
      // This will be used when deserializing elements that haven't been registered
      customElements.whenDefined('folk-shape').then((constructor) => {
        constructor.importSrc = '@labs/standalone/folk-shape.ts';
      });

      // Track selected elements
      const selectedElements = new Set();
      const statusEl = document.getElementById('status');
      const space = document.getElementById('space');

      // Add click event to select elements
      space.addEventListener('click', (e) => {
        // Only select folk-shape elements
        if (e.target.tagName.toLowerCase() === 'folk-shape') {
          if (!e.shiftKey) {
            // Clear previous selection if not shift-clicking
            clearSelection();
          }

          // Toggle selection for the clicked element
          toggleSelection(e.target);

          // Update status
          updateStatus();

          // Stop propagation to prevent space from handling the click
          e.stopPropagation();
        } else if (e.target === space || e.currentTarget === space) {
          // Deselect all when clicking on empty space (without shift)
          if (!e.shiftKey) {
            clearSelection();
            updateStatus();
          }
        }
      });

      // Toggle selection for an element
      function toggleSelection(element) {
        if (selectedElements.has(element)) {
          selectedElements.delete(element);
          element.classList.remove('selected');
        } else {
          selectedElements.add(element);
          element.classList.add('selected');
        }
      }

      // Clear all selections
      function clearSelection() {
        selectedElements.forEach((element) => {
          element.classList.remove('selected');
        });
        selectedElements.clear();
      }

      // Update status message
      function updateStatus() {
        const count = selectedElements.size;
        if (count === 0) {
          statusEl.textContent =
            'Use SHIFT+click to select multiple elements. Copy with Ctrl+C/Cmd+C, paste with Ctrl+V/Cmd+V.';
        } else {
          statusEl.textContent = `${count} element${count > 1 ? 's' : ''} selected. Copy with Ctrl+C/Cmd+C, paste with Ctrl+V/Cmd+V.`;
        }
      }

      // Function to serialize an element to JSON
      function serializeElement(element) {
        const constructor = customElements.get(element.tagName.toLowerCase());

        // Get all attributes
        const attributes = {};
        for (const attr of element.attributes) {
          attributes[attr.name] = attr.value;
        }

        // Get computed position if it's a folk-shape
        if (element.tagName.toLowerCase() === 'folk-shape') {
          // Get the computed style of the element
          const computedStyle = window.getComputedStyle(element);

          // Extract the folk-specific CSS variables that store the actual position and dimensions
          const folkX = computedStyle.getPropertyValue('--folk-x').trim();
          const folkY = computedStyle.getPropertyValue('--folk-y').trim();
          const folkWidth = computedStyle.getPropertyValue('--folk-width').trim();
          const folkHeight = computedStyle.getPropertyValue('--folk-height').trim();
          const folkRotation = computedStyle.getPropertyValue('--folk-rotation').trim();

          // Update the attributes with the current values from CSS variables
          if (folkX) attributes['x'] = folkX;
          if (folkY) attributes['y'] = folkY;
          if (folkWidth) attributes['width'] = folkWidth;
          if (folkHeight) attributes['height'] = folkHeight;
          if (folkRotation) attributes['rotation'] = folkRotation;
        }

        // Create serialized representation
        const serialized = {
          tagName: element.tagName.toLowerCase(),
          importSrc: constructor.importSrc,
          attributes: attributes,
          innerHTML: element.innerHTML,
        };

        return serialized;
      }

      // Function to deserialize an element from JSON
      async function deserializeElement(serialized) {
        const { tagName, importSrc, attributes, innerHTML } = serialized;

        // Check if the custom element is defined
        let constructor = customElements.get(tagName);

        // If not defined, import it dynamically
        if (!constructor && importSrc) {
          try {
            await import(importSrc);
            constructor = customElements.get(tagName);
          } catch (error) {
            console.error(`Failed to import ${tagName} from ${importSrc}:`, error);
          }
        }

        // Create the element
        const element = document.createElement(tagName);

        // Set attributes
        for (const [name, value] of Object.entries(attributes)) {
          element.setAttribute(name, value);
        }

        // Set inner HTML
        element.innerHTML = innerHTML;

        return element;
      }

      // Enable clipboard API for cross-page copy-paste
      document.addEventListener('copy', (e) => {
        if (selectedElements.size > 0) {
          const serializedElements = Array.from(selectedElements).map(serializeElement);
          e.clipboardData.setData('application/folk-elements', JSON.stringify(serializedElements));
          e.preventDefault();
          statusEl.textContent = `Copied ${selectedElements.size} element${selectedElements.size > 1 ? 's' : ''} to clipboard`;
        }
      });

      document.addEventListener('paste', async (e) => {
        const folkData = e.clipboardData.getData('application/folk-elements');

        if (folkData) {
          try {
            const serializedElements = JSON.parse(folkData);

            // Create a document fragment to hold all new elements
            const fragment = document.createDocumentFragment();

            // Process each serialized element
            for (const serialized of serializedElements) {
              const newElement = await deserializeElement(serialized);

              // Generate a new ID to avoid duplicates
              if (newElement.hasAttribute('id')) {
                const originalId = newElement.getAttribute('id');
                const newId = `${originalId}_copy_${Date.now().toString().slice(-5)}`;
                newElement.setAttribute('id', newId);
              }

              fragment.appendChild(newElement);
            }

            // Add all elements to the space
            space.appendChild(fragment);

            // Update status
            statusEl.textContent = `Pasted ${serializedElements.length} element${serializedElements.length > 1 ? 's' : ''} from clipboard`;
            e.preventDefault();
          } catch (error) {
            console.error('Failed to paste elements:', error);
            statusEl.textContent = 'Failed to paste elements';
          }
        }
      });

      // Add keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        // Ctrl+C or Cmd+C
        if ((e.ctrlKey || e.metaKey) && e.key === 'c' && selectedElements.size > 0) {
          document.execCommand('copy');
        }

        // Ctrl+V or Cmd+V
        if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
          document.execCommand('paste');
        }

        // Escape to clear selection
        if (e.key === 'Escape' && selectedElements.size > 0) {
          clearSelection();
          updateStatus();
        }
      });
    </script>
  </body>
</html>
