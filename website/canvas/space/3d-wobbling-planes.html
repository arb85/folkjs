<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>3D Wobbling Planes Demo</title>
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        overflow: hidden;
      }

      #space1,
      #space2 {
        position: absolute;
        width: 100%;
        height: 100%;
        transform-origin: 0 0;
        backface-visibility: hidden;
        pointer-events: none;
      }

      #space1 {
        background-color: rgba(200, 200, 200, 0.3);
      }

      #space2 {
        background-color: rgba(150, 150, 150, 0.3);
      }

      folk-shape {
        background: rgb(134, 37, 37);
        border: 1px solid rgba(0, 0, 0, 0.5);
        pointer-events: auto;
      }

      #space1 folk-shape {
        background: rgb(187, 178, 178);
      }

      folk-rope {
        position: absolute;
        inset: 0;
        pointer-events: none;
        z-index: 1000;
      }
    </style>
  </head>
  <body>
    <div id="space1">
      <folk-shape id="source1" x="250" y="100" width="50" height="50"></folk-shape>
      <folk-shape id="source2" x="400" y="300" width="75" height="75" rotation="45"></folk-shape>
      <folk-shape id="source3" x="150" y="400" width="100" height="100" rotation="90"></folk-shape>
    </div>
    <div id="space2">
      <folk-shape id="target1" x="550" y="150" width="50" height="50" rotation="45"></folk-shape>
      <folk-shape id="target2" x="300" y="400" width="75" height="75" rotation="90"></folk-shape>
      <folk-shape id="target3" x="250" y="250" width="100" height="100" rotation="135"></folk-shape>
    </div>

    <script type="module">
      import '@labs/standalone/folk-shape.ts';
      import '@labs/standalone/folk-rope.ts';
      import { Matrix } from '@lib/Matrix.ts';

      // Create ropes for each shape pair
      const shapePairs = [
        { source: 'source1', target: 'target1' },
        { source: 'source2', target: 'target2' },
        { source: 'source3', target: 'target3' },
      ];

      // Create ropes
      const ropes = shapePairs.map((pair) => {
        const rope = document.createElement('folk-rope');
        document.body.appendChild(rope);
        return {
          rope,
          sourceId: pair.source,
          targetId: pair.target,
        };
      });

      // Get plane elements
      const frontPlane = document.getElementById('space1');
      const backPlane = document.getElementById('space2');

      // Animation parameters
      const frontPlaneAnimation = {
        rotationX: 0,
        rotationY: 0,
        rotationZ: 0,
        scaleX: 1,
        scaleY: 1,
        translateX: 0,
        translateY: 0,
        translateZ: 0,
      };

      const backPlaneAnimation = {
        rotationX: 0,
        rotationY: 0,
        rotationZ: 0,
        scaleX: 1,
        scaleY: 1,
        translateX: 0,
        translateY: 0,
        translateZ: -500,
      };

      // Animation speeds (slowed down)
      const speeds = {
        frontRotationX: 0.0001,
        frontRotationY: 0.0002,
        frontRotationZ: 0.0001,
        frontScaleX: 0.00005,
        frontScaleY: 0.00007,
        frontTranslateX: 0.005,
        frontTranslateY: 0.003,

        backRotationX: 0.0002,
        backRotationY: 0.0001,
        backRotationZ: 0.0001,
        backScaleX: 0.00007,
        backScaleY: 0.00005,
        backTranslateX: 0.007,
        backTranslateY: 0.004,
      };

      // Animation limits
      const limits = {
        rotation: 0.08,
        scale: 0.15,
        translate: 15,
      };

      // Update plane transforms
      function updatePlaneTransforms(timestamp) {
        // Update front plane animation parameters
        frontPlaneAnimation.rotationX = Math.sin(timestamp * speeds.frontRotationX) * limits.rotation;
        frontPlaneAnimation.rotationY = Math.sin(timestamp * speeds.frontRotationY) * limits.rotation;
        frontPlaneAnimation.rotationZ = Math.sin(timestamp * speeds.frontRotationZ) * limits.rotation;
        frontPlaneAnimation.scaleX = 1 + Math.sin(timestamp * speeds.frontScaleX) * limits.scale;
        frontPlaneAnimation.scaleY = 1 + Math.sin(timestamp * speeds.frontScaleY) * limits.scale;
        frontPlaneAnimation.translateX = Math.sin(timestamp * speeds.frontTranslateX) * limits.translate;
        frontPlaneAnimation.translateY = Math.sin(timestamp * speeds.frontTranslateY) * limits.translate;

        // Update back plane animation parameters
        backPlaneAnimation.rotationX = Math.sin(timestamp * speeds.backRotationX) * limits.rotation;
        backPlaneAnimation.rotationY = Math.sin(timestamp * speeds.backRotationY) * limits.rotation;
        backPlaneAnimation.rotationZ = Math.sin(timestamp * speeds.backRotationZ) * limits.rotation;
        backPlaneAnimation.scaleX = 1 + Math.sin(timestamp * speeds.backScaleX) * limits.scale;
        backPlaneAnimation.scaleY = 1 + Math.sin(timestamp * speeds.backScaleY) * limits.scale;
        backPlaneAnimation.translateX = Math.sin(timestamp * speeds.backTranslateX) * limits.translate;
        backPlaneAnimation.translateY = Math.sin(timestamp * speeds.backTranslateY) * limits.translate;

        // Create front plane matrix
        const frontMatrix = new DOMMatrix();
        frontMatrix.translateSelf(
          frontPlaneAnimation.translateX,
          frontPlaneAnimation.translateY,
          frontPlaneAnimation.translateZ,
        );
        frontMatrix.rotateSelf(
          frontPlaneAnimation.rotationX * (180 / Math.PI),
          frontPlaneAnimation.rotationY * (180 / Math.PI),
          frontPlaneAnimation.rotationZ * (180 / Math.PI),
        );
        frontMatrix.scaleSelf(frontPlaneAnimation.scaleX, frontPlaneAnimation.scaleY, 1);

        // Create back plane matrix
        const backMatrix = new DOMMatrix();
        backMatrix.translateSelf(
          backPlaneAnimation.translateX,
          backPlaneAnimation.translateY,
          backPlaneAnimation.translateZ,
        );
        backMatrix.rotateSelf(
          backPlaneAnimation.rotationX * (180 / Math.PI),
          backPlaneAnimation.rotationY * (180 / Math.PI),
          backPlaneAnimation.rotationZ * (180 / Math.PI),
        );
        backMatrix.scaleSelf(backPlaneAnimation.scaleX, backPlaneAnimation.scaleY, 1);

        // Apply matrices directly
        frontPlane.style.transform = frontMatrix.toString();
        backPlane.style.transform = backMatrix.toString();
      }

      // Update rope connections
      function updateRopeConnections() {
        // Get computed transforms for both planes
        const frontMatrix = new DOMMatrix(window.getComputedStyle(frontPlane).transform);
        const backMatrix = new DOMMatrix(window.getComputedStyle(backPlane).transform);

        let _sourceId;
        ropes.forEach(({ rope, sourceId, targetId }) => {
          const sourceElement = document.getElementById(sourceId);
          const targetElement = document.getElementById(targetId);

          if (sourceElement && targetElement) {
            const sourcePos = {
              x: sourceElement.x + sourceElement.width / 2,
              y: sourceElement.y + sourceElement.height / 2,
            };
            const targetPos = {
              x: targetElement.x + targetElement.width / 2,
              y: targetElement.y + targetElement.height / 2,
            };

            // Project points onto their respective planes
            const projectedSourcePoint = Matrix.projectPointFromPlane(sourcePos, frontMatrix);
            const projectedTargetPoint = Matrix.projectPointFromPlane(targetPos, backMatrix);

            // Create zero-width/height rects at the projected points
            const sourceRectForRope = {
              x: projectedSourcePoint.x,
              y: projectedSourcePoint.y,
              width: 0,
              height: 0,
            };

            const targetRectForRope = {
              x: projectedTargetPoint.x,
              y: projectedTargetPoint.y,
              width: 0,
              height: 0,
            };

            // Update rope connection points
            rope.sourceRect = sourceRectForRope;
            rope.targetRect = targetRectForRope;
          }
        });
      }

      // Animation loop
      function animate(timestamp) {
        updatePlaneTransforms(timestamp);
        updateRopeConnections();
        requestAnimationFrame(animate);
      }

      // Start animation
      requestAnimationFrame(animate);
    </script>
  </body>
</html>
